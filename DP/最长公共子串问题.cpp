/*给定两个字符串A和B，长度分别为m和n，要求找出它们最长的公共子串，并返回其长度。例如：

　　A = "HelloWorld"

　   B = "loop"

则A与B的最长公共子串为 "lo",返回的长度为2。我们可以看到子序列和子串的区别：子序列和子串都是字符集合的子集，但是子序列不一定连续，但是子串一定是连续的。同样地，这里只给出动态规划的解法：定义dp[i][j]表示以A中第i个字符结尾的子串和B中第j个字符结尾的子串的的最大公共子串(公共子串实际上指的是这两个子串的所有部分)的长度(要注意这里和LCS的不同，LCS中的dp[i+1][j+1]一定是大于等于dp[i][j]的；但最长公共子串问题就不一定了，它的dp[i][j]表示的子串不一定是以A[0]开头B[0]开头的，但是一定是以A[i-1]、B[j-1]结尾的)，同样地， dp 的大小也为 (n + 1) x (m + 1) ，这多出来的一行和一列是第 0 行和第 0 列，初始化为 0，表示空字符串和另一字符串的子串的最长公共子串。

当我们要求dp[i][j]，我们要先判断A的第i个元素B的第j个元素是否相同即判断A[i - 1]和 B[j -1]是否相同，如果相同它就是dp[i - 1][j- 1] + 1，相当于在两个字符串都去掉一个字符时的最长公共子串再加 1；否则最长公共子串取0。所以整个问题的初始状态为：

dp[i][0]=0,dp[0][j]=0

相应的状态转移方程为：
dp[i][j]={0,dp[i−1][j−1]+1,A[i−1]!=B[j−1]A[i−1]==B[j−1]*/

class LongestSubstring {
public:
    int findLongest(string A, int n, string B, int m) {
         if(n == 0 || m == 0)
            return 0;
        int rs = 0;
        int dp[n + 1][m + 1];
        for(int i = 0 ; i <= n; i++)//初始状态
            dp[i][0] = 0;
        for(int i = 0; i <= m; i++)
            dp[0][i] = 0;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j<= m; j++)
            {
                if(A[i - 1] == B[j - 1])
                {
                    dp[i][j] = dp[i -1][j - 1] + 1;
                    rs = max(rs,dp[i][j]);//每次更新记录最大值
                }
 
                else//不相等的情况
                    dp[i][j] = 0;
            }
            return rs;//返回的结果为rs
    }
};
